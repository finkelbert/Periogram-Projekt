# ProPer analyses (IV): *Synchrony*, *Scaling*, *Mass* and *Speech-rate*

Quantifying continuous prosody with periodic energy and F0 data to quantify prosodic strength (*Mass*), to describe pitch contours (using *Synchrony* within intervals and *Scaling* between intervals) and to calculate local *Speech-rate*.

```{r clean_start}
rm(list = ls())

## Load required libraries 
require(ggplot2)
require(dplyr)
require(seewave)
require(purrr)
require(Cairo)
require(zoo)

main_df <- read.csv("data_tables/main_df.csv") %>% distinct(file, t, .keep_all = TRUE)

```

```{r boundary_detection, warning=FALSE, include=FALSE}
## pre-loop
comp_df <- mutate(
  group_by(main_df, file),
  syll_boundsSeq = na.locf(syll_bounds, na.rm=F),
  syll_boundsSeq = ifelse(is.na(syll_boundsSeq), 0, syll_boundsSeq),
  auto_bounds = NA,
  scaling = NA,
  ## compute and smooth 1st and 2nd derivatives of the periodic energy curve
  smogPP_1stDer = ifelse(t==0, 0, (smogPP_20Hz - lag(smogPP_20Hz,1))*1000),
  smogPP_1stDer = bwfilter(wave = smogPP_1stDer, f = 1000, to = 40, n = 2),
  smogPP_2ndDer = ifelse(t==0, 0, (smogPP_1stDer - lag(smogPP_1stDer,1))*20)
  )
#
## loop
nop <- function(x) x
files <- comp_df$file
files <- files[!duplicated(files)==TRUE]
# run_singles <- plyr::ldply(files, function(f) {
plyr::ldply(files, function(f) {
sel_file <- f
single_stim <- dplyr::filter(comp_df, file==sel_file)
single_stim$boundetect <- c()
# 
expSyllNum <- length(which(!is.na(single_stim$syll_bounds)))
#
## == ## == ## == ## == ## == ## == ## == ## == ## == ## == ##
## == ## == ## == ## == ## == ## == ## == ## == ## == ## == ##
#
andCond <- function(cond,bVector) (cond & bVector)
condMap <- function(cond,f,arguments,combf) {
  for (argument in arguments)
    cond %>% combf(f(argument)) -> cond
  cond
}
## determine the distance in ms (both sides) for valid local peaks
Lags <- c(1,10,20,25,30,40,50)
##
mkBoundetect <- function(single_stim) {
  sss <- single_stim$smogPP_2ndDerDyn
  ssscmp <- function(x) ( sss > x )
  ssscmpf <- function(f) function(x) ( sss > f(sss,x) )
  TRUE %>%
    andCond( ssscmp(0.05) ) %>%
    condMap( ssscmpf(lag),  Lags, andCond ) %>%
    condMap( ssscmpf(lead), Lags, andCond ) %>%
    andCond(
      ## determine left distance (in ms) from manual boundaries
      single_stim$t < single_stim$syll_boundsSeq +75 |
      ## determine right distance (in ms) from manual boundaries
      single_stim$t < lead(single_stim$syll_boundsSeq, 75)
    ) %>%
    which()
}
#
trySensitivity <- function(ee, detection_sensitivity) {
  colnames(ee$single_stim)
  if (length(ee$boundetect) >= expSyllNum)
    return( ee )
  mutate(group_by(ee$single_stim),
         smogPP_2ndDerDyn = bwfilter(
           wave = smogPP_2ndDer,
           f = 1000,
           to = detection_sensitivity,
           n = 2)) -> ee$single_stim
  ee$boundetect <- mkBoundetect( ee$single_stim )
  ee
}
#
## == ## == ## == ## == ## == ## == ## == ## == ## == ## == ##
## == ## == ## == ## == ## == ## == ## == ## == ## == ## == ##
#
e <- new.env()
e$single_stim <- single_stim
e$boundetect <- c()
e %>%
  trySensitivity(2) %>%
  trySensitivity(3) %>%
  trySensitivity(4) %>%
  trySensitivity(5) %>%
  trySensitivity(6) %>%
  trySensitivity(7) %>%
  trySensitivity(8) %>%
  trySensitivity(9) %>%
  trySensitivity(10) %>%
  trySensitivity(11) %>%
  trySensitivity(12) %>%
  trySensitivity(13) %>%
  trySensitivity(14) %>%
  trySensitivity(15) %>%
  nop() -> ee
single_stim <- ee$single_stim
boundetect <- ee$boundetect
# 
## add to dataframe
single_stim$auto_bounds[boundetect] <- single_stim$t[boundetect]
#
## write single df 
write.csv(single_stim,file=paste0("data_tables/single_stims/",sel_file,"_analysis.csv"), row.names=FALSE)
rm(single_stim,sel_file)
})
#
## Read the single df files
dir_singles <- "data_tables/single_stims/"
files <- list.files(path=dir_singles, pattern="*.csv",full.names=T)
comp_df_comb <- plyr::ldply(files, function(f){  
  singles <- read.csv(f,header=T, sep=",")
})
comp_df <- comp_df_comb
#
## add boundaries at manual 'syll_bounds' if there are no close automatic 'auto_bounds'
comp_df <- mutate(
  group_by(comp_df, file),
  # stretch auto_bounds observtions to locate missing auto_bounds
  auto_boundsSeq = na.locf(auto_bounds, na.rm=F),
  auto_boundsSeq = ifelse(is.na(auto_boundsSeq), 0, auto_boundsSeq),
  # locate missing auto_bounds (where a syll_bound exists)
  auto_bounds = ifelse(
    (!is.na(syll_bounds) & syll_bounds > auto_boundsSeq +75 & syll_bounds > lead(auto_boundsSeq, 75)),
    syll_bounds, auto_bounds),
  # re-stretch the auto_bounds observtions after change
  auto_boundsSeq = na.locf(auto_bounds, na.rm=F),
  auto_boundsSeq = ifelse(is.na(auto_boundsSeq), 0, auto_boundsSeq)
  )
#
## re-create the boundaries list
boundetected <- which(!is.na(comp_df$auto_bounds))

```


```{r plotDetecTest, warning=FALSE}

files <- comp_df$file
files <- files[!duplicated(files)==TRUE]

##################################
########### loop start ###########
plyr::ldply(files, function(f){
detect_sel_file <- f
##################################

#####################################
###### manual singles, no-loop ######
# detect_sel_file <- files[4] # or: "filename"
#####################################

auto_boundsPlot <- dplyr::filter(droplevels(comp_df), file==detect_sel_file) #%>% droplevels(auto_boundsPlot)
#
# plot derivatives to adjust automatic detector
singleBounds <- ggplot(auto_boundsPlot, aes(x=t)) +
##### Periodic energy (smogPP_XXHz)
  geom_line(aes(y=smogPP_20Hz*100), color="red", alpha=.4, size=1.5) +
#### boundaries
  geom_hline(yintercept = 0, size=.2, alpha=.5) +
  geom_vline(aes(xintercept=syll_bounds), linetype="dotted", color="gray", size=.5, alpha=.5) +
  geom_segment(aes(x=auto_bounds, xend=auto_bounds, y=0, yend=100), position = "dodge", color="red", size=1, alpha=.5, linetype = "solid", lineend = "round") +
##### Derivatives
  geom_line(aes(y=smogPP_1stDer),color="black", alpha=.4, size=1) +
  geom_line(aes(y=smogPP_2ndDer),color="gold", alpha=.8, size=1) +
  geom_line(aes(y=smogPP_2ndDerDyn*10),color="green", alpha=.6, size=1) +
##### annotations
  geom_text(aes(x=syll_mid, y=110, label=as.character(syll_label), check_overlap=T), size=3, color="black", family= "Helvetica") + 
  theme(plot.title = element_text(size = 8), panel.background = element_blank(), plot.background = element_rect(fill = "white"), panel.grid = element_blank(), axis.title = element_blank(), axis.text.x = element_text(size = 8), axis.text.y = element_text(size = 8), axis.ticks = element_blank(), strip.text = element_text(size = 8)) 
print(singleBounds)
##--save?
ggsave(singleBounds, file=paste0("plots/",detect_sel_file,"_autoBoundsPlot.pdf"),device=cairo_pdf)

##################################
############ loop end ############
})
##################################

```

The following are a set of functions that are based on the boundary detection above (*boundary_detection* chunk) and computations within and across resulting intervals (in the following *run_fun* chunk). We measure the area under the periodic energy curve (*mass*), and the center of mass of the periodic energy curve (*CoM*). We calculate local *speech-rate* in terms of the temporal distance between consecutive CoMs, and we calcualte *scaling* as the F0 distance between consecutive CoMs. We also locate the center of gravity of F0 (*CoG*), and we calcualte *synchrony* as the distance between centers (CoG - CoM).

```{r run_fun, warning=FALSE, echo=FALSE}

### Define intervals from detected boundaries
boundaries <- c(comp_df$t[boundetected],0)
l <- length(boundaries)
filenames <- c(as.character(comp_df$file[boundetected]),"")
intervals <- data.frame(
  file = filenames[1:(l-1)],
  fileEnd = filenames[2:l],
  start = boundaries[1:(l-1)],
  end = boundaries[2:l],
  stringsAsFactors = FALSE
  )
intervals <- intervals[(intervals$file == intervals$fileEnd),]
intervals$fileEnd <- NULL
#
### Interval calculation function
intervalKalk <- function(fn,fieldName) function(interval) {
  selection <- ((comp_df$t>=interval$start) &
                  (comp_df$t<interval$end) &
                  (comp_df$file == interval$file))
  comp_df[selection,] %>% fn() %>% 
    (function(x) {
      # print(fieldName)
      # print(selection)
      # print(x)
      comp_df[selection, fieldName] <<- x
      x
    })
  }
#
### Mapping function (general)
markMap <- function(.x,.f,...) {
  # print(dim (.x))
  # print(colnames (.x))
  indices <- (1:(dim(.x)[1]))
  indices %>%
    purrr::map(function(w) {.f(.x[w,]) }) %>%
    # purrr::map(function(w) {print(w); .f(.x[w,]) }) %>%
    unlist()
  .x
  }
#
### Caculation functions (specific)
# Area Under the Curve ('mass' relating to prosodic strength)
mass <- function(df) {
  x <- round(sum(df$smogPP_20Hz, na.rm=T),1) 
  x
  }
#
# length of interval with periodic energy 
intervalDuration <- function(df) {
  x <- length(which(df$smogPP_20Hz > 0)) 
  x
  }
#
# Center of Mass (center of syllabic masses)
CoM <- function(df) {
  # print(df)
  ifelse(
    sum(df$smogPP_20Hz, na.rm=T) < 5, 0, # minimum = 50 (ms) * 0.1 (smogPP) = 5
    round(sum(df$smogPP_20Hz * df$t, na.rm=T) / sum(df$smogPP_20Hz, na.rm=T)))
  }
#
# Center of Gravity (center of F0 slope) 
# CoG uses the interpolated F0 multiplied by the corresponding periodic energy fraction (0--1)
CoG <- function(df) {
  # set the floor of the F0 curve: the interval's minimum minus a fixed percentage of the overall range (.1--.25)
  f0Floor <- min(df$f0_interp_stretch_smooth, na.rm=T) - .2 * df$f0_stim_range 
  ifelse(
    sum(df$smogPP_20Hz, na.rm=T) < 5, 0, # minimum = 50 (ms) * 0.1 (smogPP) = 5
    round(sum((df$f0_interp_stretch_smooth - f0Floor) * df$t * df$smogPP_20Hz, na.rm=T) / sum((df$f0_interp_stretch_smooth - f0Floor) * df$smogPP_20Hz, na.rm=T)))
  }
#
# F0 and periodic energy values at centers
f0atCoM <- function(df) ifelse(df$CoM==0, 0, df$f0_interp_stretch_smooth[df$t == round(df$CoM)]) 
f0atCoG <- function(df) ifelse(df$CoG==0, 0, df$f0_interp_stretch_smooth[df$t == round(df$CoG)])
PERatCoM <- function(df) ifelse(df$CoM==0, 0, round(df$smogPP_20Hz[df$t == round(df$CoM)],4))
PERatCoG <- function(df) ifelse(df$CoG==0, 0, round(df$smogPP_20Hz[df$t == round(df$CoG)],4))
#
# Synchrony between CoG and CoM: 
synchrony <- function(df) {
  round(df$CoG - df$CoM)
}
#
# delete in case of re-runs
comp_df$mass <- NULL
comp_df$intervalDuration <- NULL
comp_df$CoM <- NULL
comp_df$CoG <- NULL
comp_df$f0atCoM <- NULL
comp_df$f0atCoG <- NULL
comp_df$PERatCoM <- NULL
comp_df$PERatCoG <- NULL
comp_df$synchrony <- NULL
#
### Map specific functions to dataframe
intervals %>%
  markMap(intervalKalk(mass,"mass")) %>%
  markMap(intervalKalk(intervalDuration,"intervalDuration")) %>%
  markMap(intervalKalk(CoM,"CoM")) %>%
  markMap(intervalKalk(CoG,"CoG")) %>%
  markMap(intervalKalk(f0atCoM,"f0atCoM")) %>%
  markMap(intervalKalk(f0atCoG,"f0atCoG")) %>%
  markMap(intervalKalk(PERatCoM,"PERatCoM")) %>%
  markMap(intervalKalk(PERatCoG,"PERatCoG")) %>%
  markMap(intervalKalk(synchrony,"synchrony"))
#
# change '0's to 'NA's
comp_df <- mutate(
  group_by(comp_df,file),
  CoM = ifelse(CoM==0, NA, CoM),
  CoG = ifelse(CoG==0, NA, CoG),
  f0atCoM = ifelse(f0atCoM==0, NA, f0atCoM),
  f0atCoG = ifelse(f0atCoG==0, NA, f0atCoG),
  PERatCoM = ifelse(PERatCoM==0, NA, PERatCoM),
  PERatCoG = ifelse(PERatCoG==0, NA, PERatCoG))
#
# compute scaling
f0atCoM_list <- comp_df$f0atCoM[boundetected]
realFluct_i <- which(!is.na(f0atCoM_list))
relevantFluct_i <- realFluct_i[-1]
scalist <- diff(f0atCoM_list[realFluct_i])
scalingList <- f0atCoM_list
scalingList[relevantFluct_i] <- scalist
comp_df$scaling[boundetected] <- scalingList
#
##### add, clean and scale parameters
comp_df <- mutate(
  group_by(comp_df,file),
  ## ignore weak intervals
  CoM_corr = ifelse(CoM!=lag(CoM) | (!is.na(CoM) & is.na(lag(CoM))), CoM, NA),
  CoG_corr = ifelse(CoG!=lag(CoG) | (!is.na(CoG) & is.na(lag(CoG))), CoG, NA),
  ## 'scaling': add stimulus-initial values (realtive to speaker's median F0)
  scaling = ifelse(
    auto_bounds==min(auto_bounds, na.rm=T), f0atCoM - f0_speaker_median, 
    ifelse(
      (!is.na(auto_bounds) & !is.na(f0atCoM)), scaling, NA)),
  ## 'scaling': stretch observations
  scaling = ifelse(
    !is.na(mass), na.locf(scaling, na.rm=F), NA),
  ## normalize parameters (0--1)
  scale_rel = round((abs(scaling) / f0_speaker_range) * 100, 3),
  sync_rel = round((abs(synchrony) / intervalDuration) * 100, 3),
  mass_rel = round(mass / (sum(smogPP_20Hz, na.rm=T) / length(levels(as.factor(CoM_corr)))), 2),
  intervalDuration_rel = ifelse(
    !is.na(intervalDuration), 
    round(intervalDuration / max(intervalDuration, na.rm=T), 3), NA),
  ## create plot-friendly data
  scaleLabel = ifelse(
    round(scaling)>0, paste0('+',round(scaling),'Hz (',round(scale_rel),'%)'), 
    paste0(round(scaling),'Hz (',round(scale_rel),'%)')),
  syncLabel = ifelse(
    round(synchrony)>0, paste0('+',round(synchrony),' ms (',round(sync_rel),'%)'), 
    paste0(round(synchrony),' ms (',round(sync_rel),'%)')),
  #####################################
  ############ speech-rate ############
  #####################################
  ## 'CoM': stretch observations
  CoM_seq = na.locf(CoM_corr, na.rm=F),  # CoM_seq = na.locf(CoM, na.rm=F),
  ## 'CoM: calculate consecutive CoM diffs
  CoM_diff = ifelse(
    !is.na(CoM_corr), CoM_corr - lag(CoM_seq, 2), NA),
  ## normalize CoM_diff (0--1)
  CoM_diff_rel = ifelse(
    !is.na(CoM_corr), round(CoM_diff / max(CoM_diff, na.rm=T), 3), NA),
  ## 'CoM_diff': add stimulus-initial value (realtive to interval durationss in the stimulus)
  CoM_diff_rel = ifelse(
    t == min(CoM_corr, na.rm=T), intervalDuration_rel, CoM_diff_rel),
  ## CoM_diff_rel': stretch observations to keep values @ CoM
  CoM_diff_rel = na.locf(CoM_diff_rel, na.rm=F),
  CoM_diff_rel = ifelse(
    t==CoM & !is.na(CoM), CoM_diff_rel, NA),
  ## 'CoM_diff_rel': invert values (1--0)
  CoM_diff_relInv = ifelse(!is.na(CoM_diff_rel), (CoM_diff_rel*-1) + 1, NA),
  ## 'CoM_diff_relInv': interpolate values (1--0)
  CoM_diff_relInterp = pracma::interp1(t, CoM_diff_relInv),
  ## 'CoM_diff_relInterp': stretch observations before smoothing
  CoM_diff_relInterpStretch = ifelse(
    (is.na(CoM_diff_relInterp) & t<min(which(!is.na(CoM_diff_relInterp)))),
    CoM_diff_relInterp[min(which(!is.na(CoM_diff_relInterp)))],
    ifelse(
      (is.na(CoM_diff_relInterp) & t>=max(which(!is.na(CoM_diff_relInterp)))),
      CoM_diff_relInterp[max(which(!is.na(CoM_diff_relInterp)))], CoM_diff_relInterp)),
  ## 'CoM_diff_relInterpStretch': smooth and unstretch
  CoM_diff_relSmoothInterp = bwfilter(wave = CoM_diff_relInterpStretch, f = 1000, to = 2, n = 1),
  localSpeechRate = ifelse(
    !is.na(CoM_diff_relInterp), CoM_diff_relSmoothInterp, NA)
  )

```


```{r plot, warning=FALSE}

files <- comp_df$file
files <- files[!duplicated(files)==TRUE]

##################################
########### loop start ###########
plyr::ldply(files, function(f){
sel_file <- f
##################################

#####################################
###### manual singles, no-loop ######
# sel_file <- files[3] # or: "filename"
#####################################

single_stim <- dplyr::filter(comp_df, file==sel_file)

plotUnits <- round(single_stim$f0_stim_range[1]/30)
maxBounds <- max(single_stim$auto_bounds,single_stim$syll_bounds,na.rm = T)
minBounds <- min(single_stim$auto_bounds,single_stim$syll_bounds,na.rm = T)
midLow <- round(single_stim$f0_stim_min[1]-single_stim$f0_stim_range[1]/2)
midHigh <- round(single_stim$f0_stim_max[1]-single_stim$f0_stim_range[1]/2)

plot_comp <-
  ggplot(single_stim, aes(x=t)) +
####################### F0 curves
  ##### smooth
  # geom_point(aes(y=f0_smooth),color="blue3", alpha=.3, size=.3) +
  ##### interpolated
  # geom_point(aes(y=f0_interp_stretch_smooth),color="red", alpha=.3, size=.3) +
  ##### periogram (smogPP)
  geom_line(aes(y=f0_interp_stretch_smooth),color="blue", alpha=single_stim$smogPP_20Hz, size=single_stim$smogPP_20Hz*3.5) +
####################### Periodic energy curve
  geom_line(aes(y=smogPP_20Hz*f0_stim_range+plotFloor),color="red", alpha=.75, size=.5) +
####################### Speech-rate curve
  geom_line(aes(y=localSpeechRate*f0_stim_range+plotFloor),color="springgreen4", alpha=.75, size=2.5, linetype="solid", linejoin = "round")+#, lineend = "butt", linejoin = "round") +
####################### boundaries
  geom_segment(aes(x=syll_bounds, xend=syll_bounds, y=plotFloor, yend=f0_stim_max+plotUnits*9), linetype="dotted", color="black", size=.5, alpha=.7) +
  # geom_vline(aes(xintercept=single_stim$syll_bounds), linetype="dotted", color="black", size=.5, alpha=.7) +
  geom_segment(aes(x=auto_bounds, xend=auto_bounds, y=plotFloor, yend=f0_stim_max+plotUnits*9), position = "dodge", color="red", size=.5, alpha=.5, linetype = "solid", lineend = "round") +
####################### landmarks 
  ##### CoMs
  geom_segment(aes(x=CoM_corr, xend=CoM_corr, y=plotFloor, yend=PERatCoM*f0_stim_range+plotFloor), position = "dodge", color="red", size=.5, alpha=.5, linetype = "longdash", lineend = "round") +
  geom_segment(aes(x=CoM_corr, xend=CoM_corr, y=f0atCoM+plotUnits*3, yend=f0atCoM-plotUnits*3), position = "dodge", color="red", size=.3, alpha=.9, linetype = "longdash", lineend = "round") +
  ##### CoGs
  geom_segment(aes(x=CoG_corr, xend=CoG_corr, y=f0atCoG+plotUnits*3, yend=f0atCoG-plotUnits*3), position = "dodge", color="blue", size=.3, alpha=.9, linetype = "solid", lineend = "round") +
####################### annotations
  ##### text
  geom_text(aes(x=single_stim$syll_mid, y=f0_stim_max+plotUnits*8, label=syll_label, check_overlap=T), color="black", size=3, family= "Helvetica") +
  ##### Scaling / F0 @ CoM
  geom_text(aes(x=CoM_corr, y=f0atCoM+plotUnits*4, label=scaleLabel), check_overlap=T, color="blue", size=2, family= "Helvetica") + 
  ##### Synchrony
  geom_text(aes(x=CoM_corr + (round(synchrony)/2), y=f0atCoG-plotUnits*4, label=syncLabel), check_overlap=T, color="purple", size=2, family= "Helvetica") +
  ##### Mass
  geom_text(aes(x=single_stim$CoM, y=plotFloor-plotUnits, label=mass_rel), check_overlap=T, color="red", size=2, family= "Helvetica") +
####################### legend
  ##### CoGs
  geom_segment(aes(x=minBounds-20, xend=minBounds-20, y=midHigh-plotUnits*3, yend=midHigh+plotUnits*3), color="blue", size=.3, alpha=.8, linetype = "solid", lineend = "round", position = "dodge") +
  geom_text(aes(x=minBounds-30, y=midHigh), label="CoG", color="blue", alpha=1, size=2.5, family = "Helvetica", check_overlap=T, na.rm = T, hjust="right") +
  ##### CoMs
  geom_segment(aes(x=minBounds-20, xend=minBounds-20, y=midLow+plotUnits*3, yend=midLow-plotUnits*3), color="red", size=.3, alpha=.8, linetype = "longdash", lineend = "round", position = "dodge") +
  geom_text(aes(x=minBounds-30, y=midLow), label="CoM", color="red", alpha=1, size=2.5, family = "Helvetica", check_overlap=T, na.rm = T, hjust="right") +
  ##### Scaling / F0 @ CoM
  geom_text(aes(x=maxBounds+10, y=midHigh+plotUnits*4), label="Scaling", color="blue", alpha=1, size=2.5, family = "Helvetica", check_overlap=T, na.rm = T, hjust="left") +
  geom_text(aes(x=maxBounds+10, y=midHigh+plotUnits*2), label="low < 0 < high", color="blue", alpha=1, size=2, family = "Helvetica", check_overlap=T, na.rm = T, hjust="left") +
  ##### Synchrony
  geom_text(aes(x=maxBounds+10, y=midHigh-plotUnits*2), label="Synchrony", check_overlap=T, color="purple", size=2.5, family= "Helvetica", hjust="left") +
  geom_text(aes(x=maxBounds+10, y=midHigh-plotUnits*4), label="fall < 0 < rise", check_overlap=T, color="purple", size=2, family= "Helvetica", hjust="left") +
  ##### MAss
  geom_text(aes(x=maxBounds+10, y=midLow+plotUnits), label="Mass", check_overlap=T, color="red", size=2.5, family= "Helvetica", hjust="left") + 
  geom_text(aes(x=maxBounds+10, y=midLow-plotUnits, label="weak < 1 < strong"), check_overlap=T, color="red", size=2, family= "Helvetica", hjust="left") + 
####################### plot stuff
  # xlim(minBounds-100, max(single_stim$t)) +
  ylim(single_stim$plotFloor[1]-plotUnits, single_stim$f0_stim_max[1]+plotUnits*9) +
  theme(plot.title = element_blank(), panel.background = element_blank(), plot.background = element_rect(fill = "white"), panel.grid = element_blank(), axis.title = element_blank(), axis.text.x = element_text(size = 8), axis.text.y = element_text(size = 8), axis.ticks = element_blank(), strip.text = element_text(size = 8)) 
print(plot_comp)
##--save?
ggsave(plot_comp, file=paste0("plots/",sel_file,"_plotComp.pdf"),device=cairo_pdf)

##################################
############ loop end ############
})
##################################


```

```{r minimize_comp_df}

mini_comp_df <- comp_df[c("file", "t", "speaker", "syll_mid", "syll_bounds", "syll_label", "word_mid", "word_bounds", "word_label", "f0_speaker_min", "f0_speaker_max", "f0_speaker_median", "f0_speaker_mean", "f0_speaker_range", "f0_stim_min", "f0_stim_max", "f0_stim_median", "f0_stim_mean", "f0_stim_range", "smogPP_20Hz", "smogPP_12Hz", "smogPP_8Hz", "smogPP_5Hz", "f0_interp_stretch_smooth", "f0_interp_smooth", "syll_boundsSeq", "auto_bounds", "scaling", "auto_boundsSeq", "mass", "intervalDuration", "CoM", "CoG", "f0atCoM", "PERatCoM", "f0atCoG", "PERatCoM", "PERatCoG", "synchrony", "CoM_corr", "CoG_corr", "scale_rel", "sync_rel", "mass_rel", "intervalDuration_rel", "scaleLabel", "syncLabel", "CoM_seq", "localSpeechRate")]

mini_comp_df <- droplevels(mini_comp_df)

```

```{r write_comp_df}
## Write the computation data file
write.csv(mini_comp_df, "data_tables/comp_df.csv", row.names=FALSE)
```